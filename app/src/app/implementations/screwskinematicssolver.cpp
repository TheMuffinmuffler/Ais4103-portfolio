#include "app/implementations/screwskinematicssolver.h"

#include <utility/math.h>

using namespace AIS4104;

ScrewsKinematicsSolver::ScrewsKinematicsSolver(Eigen::Matrix4d m, std::vector<Eigen::VectorXd> screws, Simulation::JointLimits limits)
    : ScrewsKinematicsSolver(std::move(m), std::move(screws), 4.e-3, 4.e-3, std::move(limits))
{
}

ScrewsKinematicsSolver::ScrewsKinematicsSolver(Eigen::Matrix4d m, std::vector<Eigen::VectorXd> space_screws, double v_e, double w_e, Simulation::JointLimits limits)
    : KinematicsSolver(std::move(limits))
    , m_ve(v_e)
    , m_we(w_e)
    , m_m(std::move(m))
    , m_screws(std::move(space_screws))
{
}

void ScrewsKinematicsSolver::set_epsilons(double v_e, double w_e)
{
    m_ve = v_e;
    m_we = w_e;
}

uint32_t ScrewsKinematicsSolver::joint_count() const
{
    return m_screws.size();
}

//TASK: Implement fk_solve using screws.
Eigen::Matrix4d ScrewsKinematicsSolver::fk_solve(const Eigen::VectorXd &joint_positions)
{
    auto[M,screw_axis]     = space_chain() ;

    Eigen::Matrix4d T = Eigen::Matrix4d::Identity();
    //generated by copilot, had problems
    for (int i = 0; i < joint_positions.size(); i++) { // from base to end-effector
        Eigen::Vector3d w = screw_axis[i].head<3>();
        Eigen::Vector3d v = screw_axis[i].tail<3>();
        T *= utility::matrix_exponential(w,v, joint_positions[i]);
    }
    return T*M;
}


Eigen::VectorXd ScrewsKinematicsSolver::ik_solve(const Eigen::Matrix4d &t_sd, const Eigen::VectorXd &j0)
{
    return ik_solve(t_sd, j0, [&](const std::vector<Eigen::VectorXd> &) { return 0u; });
}

//TASK: Implement ik_solve using screws.
Eigen::VectorXd ScrewsKinematicsSolver::ik_solve(const Eigen::Matrix4d &t_sd, const Eigen::VectorXd &j0, const std::function<uint32_t(const std::vector<Eigen::VectorXd> &)> &solution_selector)
{

    const double w_tol = m_we;
    const double v_tol = m_ve;


    const double lambda = 1e-3;

    const int MAX_ITER = 50;
    Eigen::VectorXd current_joints = j0;
    std::vector<Eigen::VectorXd> candidates;
    candidates.reserve(MAX_ITER);

    for (int iter = 0; iter < MAX_ITER; ++iter)
    {

        const Eigen::Matrix4d T_sb = fk_solve(current_joints);
        const Eigen::Matrix4d T_bs = T_sb.inverse();
        const Eigen::Matrix4d T_bd = T_bs * t_sd;


        const auto [S_e, theta_e] = utility::matrix_logarithm(T_bd);
        const Eigen::VectorXd V_e = S_e * theta_e;

        const double w_err = V_e.head<3>().norm();
        const double v_err = V_e.tail<3>().norm();


        if (w_err < w_tol && v_err < v_tol)
            return current_joints;

        const Eigen::MatrixXd Jb = body_jacobian(current_joints);
        const int m = Jb.rows();
        const Eigen::MatrixXd A = Jb * Jb.transpose() + (lambda*lambda) * Eigen::MatrixXd::Identity(m, m);
        const Eigen::VectorXd Delta_joints = Jb.transpose() * A.ldlt().solve(V_e);


        Eigen::VectorXd next_joints = current_joints + Delta_joints;
        candidates.push_back(next_joints);

        if (solution_selector)
        {
            const uint32_t idx = solution_selector(candidates);
            if (idx < candidates.size())
                next_joints = candidates[idx];
        }

        current_joints = next_joints;
    }


    return current_joints;

}

std::pair<Eigen::Matrix4d, std::vector<Eigen::VectorXd>> ScrewsKinematicsSolver::space_chain()
{
    auto [M,screw_space] = space_chain();


    Eigen::MatrixXd AdM_inv = utility::adjoint_matrix(M.inverse());
    std::vector<Eigen::VectorXd> screw_body;
    screw_body.reserve(screw_space.size());

    for (const auto& S_space : screw_space) {
        Eigen::VectorXd S_body = AdM_inv * S_space;
        screw_body.push_back(S_body);
    }
    return {M,screw_body};

}

//TASK: Implement body_chain(). You can obtain the variables to transform to body frame from space_chain().
std::pair<Eigen::Matrix4d, std::vector<Eigen::VectorXd>> ScrewsKinematicsSolver::body_chain()
{
    auto [M, screw_space] = space_chain();

    Eigen::MatrixXd AdM_inv = utility::adjoint_matrix(M.inverse());
    std::vector<Eigen::VectorXd> screw_body;
    screw_body.reserve(screw_space.size());

    for (const auto& S_space : screw_space) {
        Eigen::VectorXd S_body = AdM_inv * S_space;
        screw_body.push_back(S_body);
    }

    return {M, screw_body};

}

//TASK: Implement space_jacobian() using space_chain()
Eigen::MatrixXd ScrewsKinematicsSolver::space_jacobian(const Eigen::VectorXd &current_joint_positions)
{
    auto [M, space_screws] = space_chain();
    const int n_theta = current_joint_positions.size();
    const int n_s = space_screws.size();
    if (n_s != n_theta) {

        return Eigen::MatrixXd::Zero(6,n_s);
    }

    Eigen::MatrixXd J_space(6, n_s);
    Eigen::Matrix4d T_space = Eigen::Matrix4d::Identity();

    for (int i = 0; i < n_s; i++) {


        Eigen::Matrix<double, 6,6> AdT = utility::adjoint_matrix(T_space);
        J_space.col(i) = AdT * space_screws[i];

        Eigen::Matrix4d expSi = utility::matrix_exponential(space_screws[i].head<3>(), space_screws[i].tail<3>(), current_joint_positions[i]);
        T_space = T_space * expSi;
    }
    return J_space;
}

//TASK: Implement body_jacobian() using body_chain()
Eigen::MatrixXd ScrewsKinematicsSolver::body_jacobian(const Eigen::VectorXd &current_joint_positions)
{
    auto [M, body_screws] = body_chain();


    const int n_c = current_joint_positions.size();
    const int n_s = body_screws.size();
    if (n_s != n_c) {

        return Eigen::MatrixXd::Zero(6,n_s);
    }

    Eigen::MatrixXd J_body(6, n_s);
    int n = static_cast<int>(n_c);
    Eigen::Matrix4d T_body = Eigen::Matrix4d::Identity();
    // descending order because body frame goes from 6-1 not 1-6 like space frame. ( from end effector)
    for (int i = n - 1; i >= 0; --i)
    {

        Eigen::Matrix<double, 6,6> AdT = utility::adjoint_matrix(T_body);
        J_body.col(i) = AdT * body_screws[i];

        Eigen::Matrix4d expBi = utility::matrix_exponential(body_screws[i].head<3>(), body_screws[i].tail<3>(), -current_joint_positions[i]);
        T_body = T_body * expBi;
    }
    return J_body;
}
